## 剖析HashMap
Map有键和值的概念。

一个键映射到一个值，Map按照键存储和访问值，键不能重复，即一个键只会存储一份，给同一个键重复设值会覆盖原
来的值

使用Map可以方便地处理需要根据键访问对象的场景

数组、ArrayList、LinkedList可以视为一种特殊的Map，键为索引，值为对象

Set是一个接口，表示的是数学中的集合概念，即没有重复的元素集合

keySet、values、entrySet有一个共同的特点，它们返回的都是视图，不是复制的值，基于返回值的修改会直接
修改Map自身

### 实现原理
#### 内部组成
``` 
transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;

transient int size;

int threshold;

final float loadFactor;
```
size表示键值对的个数。table是一个Entry类型的数组，称为哈希表或哈希桶，其中的每个元素指向一个单向链表
，链表中的每个节点表示一个键值对

threshold表示阈值，当键值对个数size大于等于threshold时考虑进行扩展。一般而言，threshold等于
table.length*loadFactor

#### 保存键值对
1. 计算键的哈希值
2. 根据哈希值得到保存位置（取模）
3. 插到对应位置的链表头部或更新已有值
4. 根据需要扩展table大小

HashMap支持key为null，key为null的时候，放在table\[0]

#### 查找方法
1. 计算键的hash值
2. 根据hash找到table中的对应链表
3. 在链表中遍历查找
4. 逐个比较，先通过hash快速比较，hash相同再通过equals比较

要查找值则需要遍历，从table的第一个链表开始，从上到下，从左到右逐个节点进行访问

#### 实现原理小结
HashMap内部有一个哈希表，即数组table，每个元素table\[i]指向一个单向链表，根据键存取值，用键算出哈希
值，取模得到数组中的索引位置bucketIndex，然后操作table\[bucketIndex]指向的单向链表

存取的时候依据键的hash值，只在对应的链表中操作，不会访问别的链表，在对应链表操作时也是先比较hash值，如
果相同再用equals方法比较

Java 8对HashMap的实现进行了优化，在哈希冲突比较严重的情况下，即大量的元素映射到同一个链表的情况下（具
体是至少8个元素，且总的键值对个数至少是64），Java 8会将该列表转换为一个平衡的排序二叉树，以提高查询
效率

根据键保存和获取值的效率都很高，为O(1)，每个单向链表往往只有一个或少数几个节点，根据hash值就可以直接
快速定位

HashMap的键值对没有顺序，因为hash值是随机的

> 根据哈希值存取对象，比较对象是计算机程序的一种重要的思维方式，它使得存取对象主要依赖于自身Hash值，而
不是与其它对象进行比较，存取效率也与集合大小无关，高达O(1)，即使进行比较，也利用hash值提高比较性能

## 剖析HashSet
Set表示的是没有重复元素，且不保证顺序的容器接口，它扩展了Collection，但没有定义任何新的方法

### 应用场景
- 排重
- 保存特殊值，黑名单或白名单
- 集合运算

### 实现原理
HashSet内部是用HashMap实现的，它内部有一个HashMap实例变量
``` 
private transient HashMap<E, Object> map;
```

Map有键和值，HashSet相当于只有键，值都是相同的固定值PRESENT

### 特点
1. 没有重复元素
2. 可以高效的添加、删除元素，判断元素是否存在，效率都为O(1)
3. 没有顺序

## 排序二叉树
在计算机程序中，树是从上往下长的，也会分叉，有个根节点，每个节点可以有一个或多个孩子节点，没有孩子节点的
节点一般称为叶子节点

二叉树是一棵树，每个节点最多有两个孩子节点，一左一右，左边的称为左孩子，右边的称为右孩子

树有一个高度或深度的概念，是从根到叶子节点经过的节点个数的最大值

排序二叉树也是二叉树，但它没有重复元素，而且是有序的二叉树
    - 如果左子树不为空，则左子树上的所有节点都小于该节点
    - 如果右子树不为空，则右子树上的所有节点都小于该节点
    
### 基本算法

#### 查找
1. 首先与根节点比较，如果相同，就找到了
2. 如果小于根节点，则到左子树中递归查找
3. 如果大于根节点，则到右子树中递归查找

在排序二叉树中，可以方便的查找最小值和最大值

#### 遍历
用递归的方式
1. 访问左子树
2. 访问当前节点
3. 访问右子树

怎样构建排序二叉树呢？可以在插入、删除元素的过程中形成和保持

#### 插入
插入元素首先要找插入位置，即新节点的父节点。与查找元素类似，从根节点开始往下找
1. 与当前节点比较，如果相同，表示已经存在了，不能再插入
2. 如果小于当前节点，则到左子树中寻找，如果左子树为空，则当前节点即为要找的父节点
3. 如果大于当前节点，则到右子树中寻找，如果右子树为空，则当前节点即为要找的父节点

#### 删除
如果节点为叶子节点，则可直接删除

如果节点只有一个孩子节点，则替换待删节点为孩子节点

如果节点有两个孩子节点，则首先找该节点的后继节点，找到后继节点后，替换待删节点为后继节点的内容，然后再
删除后继节点

排序二叉树的形状与插入和删除的顺序密切相关，极端情况下，排序二叉树可能退化为一个链表

### 平衡的排序二叉树
高度平衡的定义：任何节点的左右子树的高度差最多为1.满足这个平衡定义的排序二叉树被称为AVL树。AVL树在插
入和删除节点时，通过一次或多次旋转操作来重新平衡树

在TreeMap的实现中，用的并不是AVL树，而是红黑树。

红黑树也是一种平衡的排序二叉树，也是在插入和删除节点时通过旋转操作来平衡的，但它并不是高度平衡的，而是
大致平衡的。大致是指，它确保任意一条从根到叶子节点的路径，没有任意一条路径的长度会比其他路径长过两倍

红黑树减弱了对平衡的要求，但降低了保持平衡需要的开销，在实际应用中，统计性能高于AVL树

AVL树和红黑树都是排序二叉树，都通过在插入和删除时执行开销不大的旋转操作保持了树的高度平衡或大致平衡，
从而保证了树的查找效率

### 小结
排序二叉树是一种综合效率很高的数据结构，基本的保存、删除、查找的效率都为O（h），h为树的高度。在树平衡
的情况下h为log2(N)，N为节点数

> 与哈希表一样，树也是计算机程序中一种重要的数据结构和思维方式。为了能够快速操作数据，哈希和树是两种
基本的思维方式，不需要顺序，优先考虑哈希，需要顺序，考虑树。

除了容器类TreeMap、TreeSet，数据库的索引结构也是基于树的（不过基于B树，而不是二叉树），而索引是能
够在大量数据中快速访问数据的关键

## 剖析TreeMap
在TreeMap中，键值对之间按键有序，TreeMap的实现基础是排序二叉树

TreeMap是按键而不是按值排序

### 实现原理
TreeMap内部是用红黑树实现的，红黑树是一种大致平衡的排序二叉树

#### 内部组成
``` 
private final Comparator<? super K> comparator;
private transient Entry<K, V> root = null;
private transient int size = 0;

static final class Entry<K, V> implements Map.Entry<K, V> {
    K key;
    V value;
    Entry<K, V> left = null;
    Entry<K, V> right = null;
    Entry<K, V> parent;
    boolean color = BLACK;
}
```

保存键值对：循环比较找到父节点，并插入作为其左孩子或右孩子，然后调整保持树的大致平衡

TreeMap可以高效地按键进行查找，但如果要根据值进行查找，则需要遍历

TreeMap特点：
1. 按键有序，TreeMap同样实现了SortedMap和NavigableMap接口，可以方便的根据键的顺序进行查找，如第
一个、最后一个、某一范围的键、邻近键等
2. 为了按键有序，TreeMap要求键实现Comparable接口或通过构造方法提供一个Comparator对象
3. 根据键保存、查找、删除的效率比较高，为O(h)，h为树的高度，在树平衡的情况下，h为log2(N)，N为节点数

## 剖析TreeSet
TreeSet基于TreeMap

TreeSet实现了排重和有序

## 剖析LinkedHashMap
LinkedHashMap是HashMap的子类，但内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也
位于这个双向链表中

LinkedHashMap的节点类LinkedHashMap.Entry是HashMap.Entry的子类，每个节点既在哈希表中，也位于
双向链表中

LinkedHashMap支持两种顺序，一种是插入顺序，一种是访问顺序，可通过构造方法参数配置

插入顺序：先添加的在前面，后添加的在后面，修改操作不影响顺序

访问顺序：对一个键执行get/put操作后，其对应的键值对会移到链表末尾

访问有序典型的应用是LRU缓存

> 缓存是计算机技术中一种非常有用的技术，是一个通用的提升数据访问性能的思路，一般用来保存常用的数据，容
量较小，但访问更快。

缓存的基本假设是：数据会被多次访问，一般访问数据时都先从缓存中找，缓存中没有再从主存中找，找到后再放入
缓存

缓存用于计算机技术的各个领域，CPU缓存是相对于内存而言的，内存的缓存是相对于硬盘而言的。硬盘的缓存是相对
于网络上其它机器的数据而言

LinkedHashMap也有一个对应Set接口的实现类LinkedHashSet，LinkedHashSet是HashSet的子类，内部Map
的实现类是LinkedHashMap

## 剖析EnumMap
``` 
Map<SizeEnum, Integer> map = new EnumMap<>(SizeEnum.class);
```

与HashMap不同，EnumMap需要传递一个类型信息，EnumMap是保证顺序的

EnumMap有如下实例变量：
``` 
//类型信息
private final Class<K> keyType;
//所有可能的枚举值
private transient K[] keyUniverse;
//键对应的值
private transient Object[] vals;
//size表示键值对个数
private transient int size = 0;
```

EnumMap内部有两个数组，长度相同，一个表示所有可能的键，一个表示对应的值，值为null表示没有该键值对，
键都有一个对应的索引，根据索引可直接访问和操作其键和值，效率很高

## 剖析EnumSet
EnumSet的实现与EnumMap没有任何关系，而是用极为精简和高效的位向量实现的

EnumSet是一个抽象类，提供了若干静态工厂方法，如：
``` 
// 创建一个指定枚举类型的EnumSet，不含任何元素。创建EnumSet对象的实际类型是EnumSet的子类
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType);
```

位向量：用一个位表示一个元素的状态，用一组位表示一个集合的状态，每个位对应一个元素，而状态只可能有两种

EnumSet是一个抽象类，它没有定义使用的向量长度，它有两个子类：RegularEnumSet和JumboEnumSet。

RegularEnumSet使用一个Long类型的变量作为位向量，long类型的位长度是64，而JumboEnumSet使用一个
long类型的数组。如果枚举值个数小于等于64，则静态工厂方法中创建的就是RegularEnumSet，如果大于64
就是JumboEnumSet

EnumSet有如下实例变量：
``` 
//类型信息
final Class<E> elementType;
//枚举类的所有枚举值
final Enum[] universe;
```

> 对于只有两种状态，且需要进行集合运算的数据，使用位向量进行表示、位运算进行处理，是计算机程序中一种
常用的思维方式

Java中有一个更为通用的可动态扩展长度的位向量容器BitSet，可以方便地对指定位置的位进行操作，与其他位
向量进行位运算



