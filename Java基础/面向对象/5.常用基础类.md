## 包装类
Java的8种基本类型都有对应的包装类

包装类，是一个内部有实例变量，保存对应的基本类型的值。这个类一般还有一些静态方法、静态变量和实例方法，以
方便对数据进行操作

Java中很多代码只能操作对象，为了能操作基本类型，需要使用其对应的包装类

### 基本用法
将基本类型转换为包装类的过程，一般称为"装箱"：new或valueOf。一般建议使用valueOf方法，new每次都会创
建一个新对象，而除了Float和Double外的其他包装类，都会缓存包装类对象，减少需要创建对象的次数，节省空间，
提升性能

而将包装类型转换为基本类型的过程，则称为拆箱：xxxValue()

Java 5以后引入了自动装箱和拆箱技术，可以直接将基本类型复制给引用类型，反之亦可

### 共同点
1. 所有包装类都重写了Object类的equals、hashCode、toString方法
    - equals：实际比较其包装的基本类型值
    - hashCode：返回一个对象的哈希值，哈希值是一个int类型的数，由对象中一般不变的属性映射得来，用于
    快速对对象进行区分、分组等。一个对象的哈希值不能改变，相同对象的哈希值必须一致。不同的对象哈希值一
    搬应不同，但不是必需
        - 对两个对象，如果equals方法返回true，则hashCode也必须一样，反之不要求
        - 质数用于哈希比较好，不容易冲突
2. Comparable
    > 接口只有一个方法compareTo，当前对象与参数对象进行比较，在小于、等于、大于参数时，应分别返回-1、
    0、1
3. 包装类和String
    - valueOf(String str)：根据字符串表示返回包装类对象
    - parseXXX(String str)：根据字符串表示返回基本类型值
    - 进制转换
4. 常用常量
5. Number：六种数值类型
6. 不可变性
    - 所有包装类都声明为了final
    - 内部基本类型值是私有的，且声明为了final
    - 没有定义setter方法
    
### 剖析Integer与二进制算法
1. 位翻转
将int当作二进制，左边的位与右边的位进行互换
```
//按位进行互换
public static int reverse(int i)
//按byte进行互换
public static int reverseBytes(int i)
```
CPU指令并不能高效地操作单个位，它操作的最小数据单位一般是32位（32位机器），另外，CPU可以高效的实现移
位和逻辑运算，但实现加减乘除运算则比较慢

reverse是在充分利用CPU的这些特性，并行高效地进行相邻位的交换，也可以通过其他更容易理解的方式实现相同
功能，但很难比这个代码更高效

2. 循环移位
```
public static int rotateLeft(int i, int distanse);
public static int rotateRight(int i, int distanse);
```
如果是循环左移两位，则原来最高两位会移到最右边，就像一个左右相接的环一样

3. valueOf的实现
Integer.valueOf使用了IntegerCache。这是一个私有静态内部类

IntegerCache表示Integer缓存，其中的cache变量是一个静态化数组，在静态初始化代码块中被初始化，默认情
况下，保存了-128~127个整数对应的Integer对象

在valueOf代码中，如果数值位于被缓存的范围，即默认-128~127，则直接从IntegerCache中获取已预先创建的
Integer对象，只有不在缓存范围时，才通过new创建对象

这种共享常用对象的思路，叫享元模式

### 剖析Character
Character除了封装了一个char外，还封装了Unicode字符级别的各种操作，是Java文本处理的基础

1. Unicode基础
Unicode给世界上每个字符分配了一个编号，编号范围为0x000000~0x10FFFF。编号范围在0x0000~0xFFFF的字
符为常用字符集，称BMP字符。编码范围在0x10000~0x10FFFF的字符叫做增补字符

Unicode主要规定了编号，但没有规定如何把编号映射为二进制

UTF-16是一种编码方式，或者叫映射方式，它将编号映射为2个或4个字节，对BMP字符，用两个字节表示，增补字符
则使用4个字节表示。UTF-16定义了一个公式，可以将编号与4字节表示进行相互转换

Java内部采用UTF-16编码，char表示一个字符，但只能表示BMP中的字符，对于增补字符，需要使用两个char表示

使用int可以表示任意一个Unicode字符，低21位表示Unicode字符，高11位设为0。整数编号在Unicode中一般称
为代码点（code point），表示一个Unicode字符。还有一个词代码单元（code point），表示一个char

2. 检查code point和char
3. code point与char的转换
4. 按code point处理char数组或序列
5. 字符属性：字符类型
6. 字符转换：大小写、数值

## 剖析String
### 走进String内部
String类内部用一个字符数组表示字符串，实例变量定义为：
```
private final char value[]
```

String有两个构造方法，可以根据char数组创建String变量。String会根据参数新创建一个数组，并复制内容，
而不会直接用参数中的字符数组

### 编码转换
String内部是按UTFBE处理字符的，对BMP字符，使用一个char，两个字节，对于增补字符，使用两个char，四
个字节

Java使用Charset类表示各种编码，defaultCharset返回系统的默认编码，forName返回给定编码名称的
Charset对象

String类的getBytes()返回系统默认编码的字节表示，getBytes(String charsetName)返回指定编码的字
节表示

Java的内部表示与各种编码是不同的，但可以相互转换

### 不可变性
与包装类类似，String类也是不可变类。String类也声明为final，不能被继承，内部char数组value也是final
的，初始化后就不能改变了

String类中提供了很多看似修改的方法，其实是通过创建新的String对象来实现的，原来的String对象不会改变

与包装类类似，定义为不可变类，程序可以更为简单，安全，容易理解。但如果频繁修改字符串，而每次修改都新建
一个字符串，那么性能太低，这时应该考虑Java中的另两个类，StringBuilder和StringBuffer

### 常量字符串
Java中的字符串常量是非常特殊的，除了可以直接赋值给String变量外，它自己就像一个String类型的对象，可以
直接调用String的各种方法

这些常量就是String类型的对象，在内存中，它们被放在一个共享的地方，这个地方称为"字符串常量池"，它保存所
有的字符串常量，每个常量只会保存一份，被所有使用者共享

当通过常量的形式使用一个字符串的时候，使用的就是常量池中的那个对应的String类型的对象

### hashCode
hash变量缓存了hashCode方法的值

String的hash计算公式s[i]*31^(n-(i+1))可以让hash值与每个字符的值有关，也与每个字符的位置有关。使用
31大致因为两个原因：一方面可以产生更分散的散列；另一方面计算效率比较高，31*h与32*h-h即(h<<5)-h等价，
可以用更高效率的移位和减法操作来代替乘法操作

在Java中普遍采用以上思路来实现hashCode

### 正则表达式
正则表达式可以理解为一个字符串，但表达的是一个规则，一般用于文本的匹配、查找、替换等

Java 9对String的实现进行了优化，它的内部不是char数组，而是byte数组，如果字符都是ASCII字符，它就可以
使用一个字节表示一个字符，而不用UTF-16BE，节省内存

## 剖析StringBuilder
StringBuilder用法很简单，创建StringBuilder对象，通过append方法添加字符串，然后通过toString方法获
取构建完成的字符串

StringBuilder类也封装了一个字符数组，它不是final的，可以修改

append会直接复制字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。扩展策略是当前长度乘2再加2，
如果长度不够，采用需要的最小长度

在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛用于各种内存分配相关的计算机程序中

toString方法基于内部数组新建了一个String，String不会使用StringBuilder的value数组，以保证String
的不变性

### String的+和+=运算符
Java中String可以直接使用+和+=，Java编译器一般会生成StringBuilder，+和+=操作都会转换为append

在复杂的情况下，如循环内，Java编译器可能会生成过多的StringBuilder

## 剖析Arrays类
数组是存储多个同类型元素的基本数据结构，数组中元素在内存连续存放，可以通过数组下标直接定位任意元素

### 用法
1. Arrays的toString方法可以方便地输出一个数组的字符串形式。它有9个重载的方法，包括8个基本类型数组和
1个对象类型数组
2. sort可以从小到大升序排列，除了基本类型，sort还可以直接接受对象类型，但对象需要实现Comparable接口
    > 传递比较器Comparator给sort方法，体现了程序设计中一种重要的思维方式。将不变和变化相分离，排序
    的基本步骤和算法是不变的，但按什么排序是变化的，sort方法将不变的算法设计为主题逻辑，而将变化的排序
    方式设计为参数，允许调用者动态指定，这也是一种常见的设计模式，成为策略模式，不同的排序方式就是不同
    的策略
3. binarySearch在已排序的数组中进行二分查找
4. copyOf复制一个新数组
5. equals判断两个数组是否相同
6. fill给数组中的每个元素设置一个相同的值
7. hashCode计算一个数组的哈希值

### 多维数组
多维数组只是一个假象，只有一维数组，只是数组中的每个元素还可以是一个数组

Arrays中的toString、equals、hashCode都有对应的针对多维数组的方法：deepToString、deepEquals
、deepHashCode，这些deepXXX方法，都会判断参数中的元素是否也为数组，如果是，会递归进行操作

### 查找
二分查找

### 排序
排序是计算机程序中一个非常重要的方面，几十年来，计算机科学家和工程师们对此进行了大量的研究，设计了各种
各样的算法，进行了大量的优化。一般而言，没有一个最好的算法，不同算法往往有不同的适用场合

对于基本类型的数组，Java采用的算法是双枢轴快速排序（Dual-Pivot QuickSort）。这个算法是Java 7引入
的，在此之前，Java采用的算法是普通的快速排序。双枢轴快速排序是对快速排序的优化

对于对象类型，Java采用的算法是TimSort。TimSort也是在java 7引入的，在此之前，Java采用的是归并排序。
TimSort实际上是对归并排序的一系列优化

在这些排序算法中，如果数组长度比较小，它们还会采用效率更高的插入排序

为什么基本类型和对象类型的算法不一样呢？
排序算法有一个稳定性的概念，所谓稳定性就是对值相同的元素，如果排序前和排序后，算法可以保证它们的相对顺
序不变，那算法就是稳定的，否则就是不稳定的。
快速排序更快，但不稳定，而归并排序是稳定的。对于基本类型，值相同就是完全相同，所以稳定不稳定没关系。但
对于对象类型，相同只是比较结果一样，它们还是不同的对象，其它实例变量也不见得一样，稳定不稳定可能就有关
系了，所以采用归并排序

## 剖析日期和时间（Java 8之前）
### 基本概念
1. 时区
同一时刻，世界上各个地区的时间可能是不一样的，具体时间与时区有关
全球一共有24个时区，英国格林尼治是0时区，北京是东八区，当格林尼治凌晨1点，北京是早上9点
GMT是格林尼治标准事件，0时区也称为GMT+0时间，北京的时间就是GMT+8:00

2. 时刻和纪元时
所有计算机系统内部都用一个整数表示时刻，这个整数是距离格林尼治标准时间1970-01-01 00:00:00的毫秒数

格林尼治标准事件也被称为Epoch Time（纪元时）

对于1970年以前的时间，使用负数表示

3. 年历
公历是世界上广泛采用的年历

### 日期和时间API
1. Date
    - 表示时刻，即绝对时间，与年月日无关
    - 内部主要是一个long类型的值fastTime，表示距离纪元时的毫秒数
    - System.currentTimeMillis()是一个常用的方法，它返回当前时刻距离纪元时的毫秒数

2. Calendar
    - 表示年历，Calendar是一个抽象类，其中表示公历的子类是GregorianCalendar
    - Calendar表示与TimeZone和Locale相关的日历信息，可以进行各种相关的计算
    - Calendar内部有一个表示时刻的毫秒数，time；还有一个数组fields[]，表示日历中各个字段的值
    - Calendar做了一项非常繁琐的工作，根据TimeZone和Locale，在绝对时间毫秒数和日历字段之间自动进
    行转换，且对不同日历字段的修改进行自动同步更新
    

3. DateFormat
    - 表示格式化，能够将日期和时间与字符串进行互相转换，DateFormat也是一个抽象类，最常用
    的子类是SimpleDateFormat
    - 它主要有两个主要的方法，format将Date转换为字符串，parse将字符串转换为Date

4. TimeZone
    - 表示时区，抽象类
    - TimeZone.getDefault返回当前默认时区
    - Java中的系统属性user.timezone保存的就是默认时区，可以通过如下方式获得：
        ```
        System.getProperty("user.timezone")
        ```
        系统属性可以在Java启动的时候传入参数进行更改

5. Locale
    - 表示国家和语言
    - Locale有两个主要参数，一个是国家，另一个是语言

### 局限性
1. Date中的方法参数与常识不符合，过时方法标记容易被人忽略，产生误用
2. Calendar API设计不是很成功，一些简单的操作都需要多次方法调用，写很多代码；另外还难以进行比较复杂
的日期操作
3. DateFormat/SimpleDateFormat不是线程安全的。多个线程使用一个DateFormat实例的时候，会有问题，
因为DateFormat内部使用了一个Calendar实例对象，多线程同时调用的时候，这个Calendar实例的状态可能
会紊乱。有如下方式解决：
    - 每次使用DateFormat都新建一个对象
    - 使用线程同步
    - 使用ThreadLocal
    - 使用JodaTime或Java 8的API，它们是线程安全的

## 随机
### Math.random
Java中对随机最基本的支持是Math类中的静态方法random()，它生成一个0~1的随机数，类型为double，包括
0但不包括1

内部它使用了一个Random类型的静态变量randomNumberGenerator，调用random就是调用该变量的
nextDouble方法，这个Random变量只有在第一次使用的时候才创建

### Random
Random类提供了更为丰富的随机方法

除了默认构造方法，Random类还有一个构造方法，可以接受一个long类型的种子参数。种子决定了随机产生的序列，
种子相同，产生的随机数序列就是相同的

指定种子是为了实现可重复的随机

#### 随机的基本原理
Random产生的随机数不是真正的随机数，相反，它产生的随机数一般称为伪随机数。真正的随机数比较难以产生，计
算机程序中的随机数一般都是伪随机数

伪随机数都是基于一个种子数的，然后每需要一个随机数，都是对当前种子进行一些数学运算，得到一个数，基于这个
数得到需要的随机数和新的种子

数学运算是固定的，所以种子确定后，产生的随机数序列就是确定的，确定的数字序列当然不是真正的随机数，但种子
不同，序列就不同，每个序列中的数字的分布也都是比较随机和均匀的，所以称之为伪随机数

Random的默认构造方法中没有传递种子，它会自动生成一个种子，这个种子是一个真正的随机数

生成随机数的方法叫线性同余随机数生成器

随机数基于一个种子，种子固定，随机数序列就固定，默认构造方法中，种子是一个真正的随机数

