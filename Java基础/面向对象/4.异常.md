## 初识异常
### NullPointerException（空指针异常）
变量还没有初始化，就调用其实例方法

当JVM遇到NPE异常时，启用异常处理机制，首先创建一个异常对象，这里是类NullPointerException的对象，然
后查找谁能处理这个异常。如果没有代码能处理这个异常，则Java启用默认处理机制，打印异常栈信息到屏幕，并退
出程序

异常栈信息包括了从异常发生点到最上层调用者的轨迹，还包括行号

Java的默认异常处理机制是退出程序，异常发生点后的代码都不会执行

关键字：throw，抛出异常

throw关键字可以与return关键字进行对比。return代表正常退出，throw代表异常退出；return的返回位置是确
定的，就是上一级调用者，而throw后执行哪行代码则经常是不确定的，由异常处理机制动态决定

异常处理机制会从当前函数开始查找看谁"捕获"了这个异常，当前函数没有就查看上一层，直到主函数，如果主函数也
没有，就使用默认机制，即输出异常栈信息并退出，这正是我们在屏幕输出中看到的

关键字：try/catch，捕获异常

## 异常类
### Throwable
Throwable是所有异常类的父类

message参数：表示异常消息

cause参数：标识触发该异常的其他异常。异常可以形成一个异常链，上层的异常由底层的异常触发，cause表示底层
异常

在所有Throwable构造方法内部，都有一句重要的函数调用：fillInStackTrace()，它将异常信息保存下来

### 异常类体系
Throwable是所有异常的基类，它有两个子类：Error和Exception

Error表示系统错误或资源耗尽，由Java系统自己使用，应用程序不应抛出和处理。如VirtualMachineError、
OutOfMemoryError和StackOverflowError

Exception表示应用程序错误，它有很多子类，如IOException、RuntimeException、SQLException，应用
程序也可以通过继承Exception或其子类创建自定义异常

RuntimeException比较特殊，它的名字有点误导，因为其它异常也是运行时产生的，它表示的实际含义是
unchecked异常，Exception的其它子类和Exception自身则是checked异常，Error及其子类也是unchecked
异常

对于checked异常，Java会强制要求程序员进行处理，否则会有编译错误，而对于unchecked异常则没有这个要求

异常类的名字本身就代表了异常的关键信息，无论是抛出还是捕获异常，使用合适的名字都有助于代码的可读性和可
维护性

### 自定义异常
一般是继承Exception或者它的某个子类。

父类是RuntimeException或它的某个子类，则自定义异常也是unchecked异常

如果是Exception或Exception的其他子类，则自定义异常是checked异常

## 异常处理
### catch匹配
异常处理机制将根据抛出的异常类型找第一个匹配的catch块，找到后执行，不再执行其它catch块。如果没有找到
会继续到上层方法中查找

抛出的异常类型是catch中声明异常的子类也算匹配，所以需要将最具体的子类放在前面

### 重新抛出异常
在catch块内处理完后，可以重新抛出异常。异常可以是原来的，也可以是新建的

为什么要抛出：因为当前代码不能够完全处理该异常，需要调用者进一步处理

为什么要抛出一个新的异常：因为当前异常不太合适，可能信息不够，需要补充；还可能是过于细节，不便于调用者
理解和使用，如果调用者对细节感兴趣，还可以继续通过getCause()获取到原始异常

### finally
finally内的代码不管有无异常发生，都会执行

如果在try或者catch语句内有return语句，则return result语句在finally语句执行结束后才执行，但
finally并不能改变返回值：

在执行到try内的return语句前，会先将返回值result保存在一个临时变量中，然后才执行finally语句
，最后try再返回那个临时变量，finally中对result的修改不会被返回

如果在finally中也有return语句，try和catch内的return会丢失，实际会返回finally中的返回值

finally中有return不仅会覆盖try和catch内的返回值，还会掩盖try和catch内的异常，就像异常没发生一样

finally中如果抛出了异常，则原异常也会被掩盖

一般而言，为避免混淆，应该避免在finally中使用return语句或者抛出异常

### try-with-resources
该语法针对是吸纳了java.lang.AutoCloseable接口的对象

资源的声明和初始化放在try语句内，在执行完try语句后，会自动调用资源的close方法

### throws
声明一个方法可能抛出的异常，且没有对这些异常进行处理，或者没处理完，调用者必须进行处理

对于checked异常，必须进行声明，没有声明则无法抛出

如果一个方法内调用了另一个声明抛出checked异常的方法，则必须处理这些checked异常，可以catch，也可以
继续throws

无论是checked异常还是unchecked异常，无论是否出现在throws声明中，都应该在合适的地方以适当的方式处理
异常，既然都要进行处理异常，checked异常的强制声明和处理就显得繁琐，尤其是调用层次比较深的情况下

## 如何使用异常
### 异常应该仅用于异常情况
真正抛出异常的时候，应该抛出异常，而不是返回特殊值

### 异常处理的目标
处理的目标可以分为恢复和报告

恢复是指通过程序自动解决问题。

报告的最终对象可能是用户，即程序使用者，也可能是系统运维人员或程序员。报告的目的也是为了恢复，但这个恢
复经常需要人的参与

对用户，如果用户输入错误，可以提示用户具体哪里输入不对；如果是编程错误，可以提示用户系统错误，建议联系客
服；而第三方问题，可以提示用户稍后重试

### 异常处理的一般逻辑
如果自己知道怎么处理异常，就进行处理；如果可以通过程序自动解决，就自动解决；如果异常可以被自己解决，就
不需要再向上报告

如果自己不能完全解决，就应该向上报告。有额外信息则可以提供，有助于分许和解决问题就应该提供，可以以原异
常为cause重新抛出一个异常

总有一层代码需要为异常负责，可能是知道如何处理该异常的代码，可能是面对用户的代码，也可能是主程序。如果
异常不能自动解决，对于用户，应该根据异常信息提供用户能理解和对用户有帮助的信息；对运维和开发人员，则应
该输出详细的异常链和异常栈到日志

> 在有了异常机制后，程序的正常逻辑与异常逻辑可以相分离，异常情况可以集中进行处理，异常还可以自动向上传
递，不再需要每层方法都进行处理，异常也不再可能被自动忽略，从而，处理异常情况的代码可以大大减少，代码的
可读性、可靠性、可维护性也都可以得到提高





